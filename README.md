Vizualizer
==========

VizualizerはWEBデザイナーが簡易的にも機能を追加できるようにするためのPHPフレームワークです。
テンプレートとしては、Smartyを使っておりますが、基本的にはプログラマでなくても、レゴのように機能を貼付けていくことで、処理を実現できるようにすることが目的となっております。

### 基本的な使い方

最初に、システムを設置するディレクトリを用意し、そこを書き込み可能にします。（WEBサーバーのプロセスで書き込み可能にする必要があります）
必要なディレクトリはフレームワーク側でほとんど自動的に作成するので、意識する必要はありません。

ディレクトリの準備ができたら、次にフレームワーク本体をインストールします。
composerでインストールできるので、composer.jsonを以下のように作成します。

必須となるのはvizualizerとsmartyのパッケージだけです。
他のパッケージは必要な機能を取捨選択してインストールします。

今回は開発中も含めた最新版を落とすためにdev-developをバージョンに指定していますが、運用に利用する場合は適切なバージョン番号を利用するといいでしょう。

    {
        "require": {
            "naonaox1126/vizualizer": "dev-develop",
            "naonaox1126/vizualizer_admin": "dev-develop",
            "naonaox1126/vizualizer_address": "dev-develop",
            "naonaox1126/vizualizer_member": "dev-develop",
            "naonaox1126/vizualizer_shop": "dev-develop",
            "smarty/smarty": ">=3.1.0"
         }, 
        "require-dev": {
            "naonaox1126/vizualizer": "dev-develop",
            "naonaox1126/vizualizer_admin": "dev-develop",
            "naonaox1126/vizualizer_address": "dev-develop",
            "naonaox1126/vizualizer_member": "dev-develop",
            "naonaox1126/vizualizer_shop": "dev-develop",
            "smarty/smarty": "dev-trunk"
        }
    }

ここまで準備できましたら、composerを利用してインストールします。詳細はcomposerのサイトで確認してください。

フレームワークのインストールに成功すると、vendorというディレクトリが作成されているかと思います。

次に、呼び出し元となるindex.phpと.htaccessを設定します。

index.phpの内容は以下のような感じになります。
Packagistのautoload.phpを呼び出してVizualizer::startup()を実行するだけです。
あとはフレームワークがよろしく初期化してくれるので、特に何もする必要はありません。

    <?php
    require __DIR__ . "/vendor/autoload.php";
    
    Vizualizer::startup();

次に.htaccessの内容です。
.htaccessというだけあって、Apache前提ですが、やっていることはファイルの存在しないアクセスをindex.phpでリライトするということだけです。
同じことができればnginxでも同様にうごく（はず）。

    # Rewriteの有効化
    RewriteEngine on
    
    # htmlの場合はindex.phpを呼び出す。
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^(.+)$ index.php [L]

この2つをシステムのルートに配置したら、今度は設定ファイルを作成します。
ファイルはシステムのルートに_configureディレクトリを作成し、その中に配置します。
設定ファイルは以下のようなルールで作成します。
例では、test.hoge.comというドメインで利用する場合の設定として説明します。

* configure.php
デフォルト設定のファイルです。条件に該当する設定がなかった場合、この設定が適用されます。
* configure_hoge.com.php
親ドメイン用の設定ファイルです。個別のサブドメインの設定がなかった場合、この設定が適用されます。
主な用途として、サブドメインでシステムを展開するようなASPにする場合に利用します。
* configure_test.hoge.com.php
利用するサブドメイン用の設定ファイルです。このファイルがある場合は、優先的に利用されます。

設定ファイルの内容は通常のPHPファイルと同様に作成できます。設定ごとに利用したいPHPコードがある場合は、ここに記述することもできます。
設定の記述方法ですが、
`Vizualizer_Configure::set("キー", "値");`
を羅列していきます。

利用可能なキーとしては以下のものがあります。（あくまで一例です。）
* timezone
システムのタイムゾーンを設定します。（デフォルト：Asia/Tokyo）
* locale
システムの言語ロケールを設定します。（デフォルト：ja_JP.UTF-8）
* debug
デバッグ設定を行います。（デフォルト：true）
trueにしている場合はデバッグログを出力するのと、PHPのログとしてE_STRICT以外全て出力するようになります。
* display_error
ログの表示状態を設定します。（デフォルト：On）
Onにしていると、PHPのログを画面に表示するようになります。
* site_code
サイト自体の識別コードを設定します。（デフォルト：default）
ログなどのファイルにも利用されますので、わかりやすい名前を設定してください。
* site_name
サイト自体の名前を設定します。（デフォルト：デフォルトサイト）
* site_domain
サイトのドメインを設定します。（デフォルト：$_SERVER[SERVER_NAME]）
* database
データベースの接続を設定します。（デフォルト：設定なし）
定義方法は以下の通り
    "default" => array(
        "read" => array(
            "dbtype" => "mysql", "host" => "接続ホスト",
            "user" => "接続ユーザー", "password" => "接続パスワード",
            "database" => "admin_tools", "query" => ""
        ),
        "write" => array(
            "dbtype" => "mysql", "host" => "接続ホスト",
            "user" => "接続ユーザー", "password" => "接続パスワード",
            "database" => "admin_tools", "query" => ""
        )
    )
最初のキーは特に制限しない場合はdefaultにします。
プラグインパッケージを利用する場合で、それ用に別でDBを用意する場合はパッケージ名を指定します。
また、readとwriteは読み込み用のクエリの場合はread、書き込み用のクエリはwriteの接続設定を利用します。
queryは特に設定をする必要はありませんが、エンコードで不具合が発生する場合はSET NAMESをするといいでしょう。

設定ファイルまで作成が終わったら、今度はテンプレートを設置します。
テンプレートはtemplatesディレクトリを作成し、その中に配置します。
templatesの中にはdefault、sphone、mobile、android、iphoneなどをサブディレクトリとして配置します。
それぞれ、PC用、スマホ／タブレット用、フューチャーフォン用、Android端末用、iOS端末用に利用できます。
なお、作成していない場合は、Android端末用とiOS端末用はスマホ／タブレット用、スマホ／タブレット用とフューチャーフォン用はPC用がそれぞれ代替として使用されます。
ですので、特に端末ごとの切り替えが不要な場合はdefaultのみ作成すれば問題ありません。

テンプレートのディレクトリまで作成が終わったら、テンプレートを配置します。
配置の方法としては、単純にHTMLファイルをテンプレートルートがシステムルートと仮定して配置すれば問題ありません。

DBなどと連携した機能を利用しないのであれば、これだけで確認が可能です。
WEBデザイナーからプログラマに渡す際には、基本的な画面遷移がここで確認できるようにしておけば、プログラマは各ページに機能を貼付けて行くだけでOKです。

テンプレートとしてはSmartyを使っておりますので、Smartyの知識があれば、パーツを共通化させることも可能です。
その際、共通化したパーツにモジュールタグを埋め込むと、そのパーツを利用している全てのページに処理を適用することもできます。

■モジュールの使い方
各ページを表示する際に実行したい処理をmetaタグに設定します。
そのmetaタグのnameにはloadmoduleを、contentには呼び出したいモジュールの名前を指定します。
モジュールは後述のモジュール以外にmetaタグに設定できるものも含めて、HTMLに記載された順序で実行されます。
必要な追加パラメータはモジュール毎に異なりますが、よく利用されるものとして以下のものがあります。
（ただし、必ず指定の効果があるかどうかはモジュールに依存します）

* error
モジュールで例外が発生した際に、エラーページのテンプレートを指定することで、エラーページに遷移することが可能です。
* sort_key
並べ替えに利用するリクエストパラメータのキー名を指定します。
* key_prefix
キーとして共通して設定されるプレフィックスを設定します。
特定のキーを持つもののみを対象にする場合などに利用します。
* continue
登録処理などで完了後リロードするモジュールなどの場合、このパラメータを設定することで、リロードをせずに次の処理を実行させることができます。
* wkey
検索結果などのキー制限をマニュアルで行う場合に指定します。後述のwvalueとセットで設定します。
* wvalue
検索結果などのキー制限をマニュアルで行う場合に指定します。wkeyに対応する条件となる値を設定します。

また、モジュールは同じ名前かつ同じパラメータで複数回呼び出された場合、最初に呼び出されたもののみが有効になります。
例えば、入力エラーチェックで同じキーに対して複数回呼び出してしまった場合、2回目のモジュールはスキップされますので、同じエラーメッセージが重複して表示されることはありません。

■モジュール以外にmetaタグに設定できるもの。
metaタグに設定するものでloadmodule以外にcontentに設定することで機能するものには以下のものがあります。

* redirect
タグの位置に処理が来た際に、ページをリダイレクトします。
* shift
タグの位置に処理が来た際に、別のテンプレートを呼びだします。
